Merge sort is an efficient general-purpose comparison-based sorting algorithm. Most merge sort implementations produce a stable sort, which means the order of equal elements is the same in input and output.
Merge sort is a divide and conquer algorithm, and works by first dividing the unsorted list into n sublists, n being dependent on the amount of items in a list, by splitting the list in half. Sublists are then merged back together one by one by first comparing the elements of sublists together and splicing the together in order.
Merge sort has an average complexity of O(n log n), where n is the number of items in the list, and the same worst case performance. Merge sort is one of the most efficient often used sorting algorithms and has a better average performance than, for example, quicksort. Merge sort is more efficient than quicksort in situations where the data in the list can only be efficiently accessed sequentially.

#Pseudocode

//TopDownMergeSort(a[], B[], n)//	CopyArray(A, 0 , n, B)//	TopDownSplitmerge////TopDownsplitMerge(B[], iBegin, iEnd, A [])//	if iEnd - iBegin <= 1://		return//	end if////	iMiddle = (iEnd + iBegin ) / 2//	TopdownSplitMerge(A, iBegin, iMiddle, B)//	topDownSplitMerge(A, iMiddle, iEnd, B)//	TopDownMerge(B, iBegin, iMiddle, iEnd, B[])////TopDownMerge(A[], iBegin, iMiddle, iEnd, B[])//	i = iBegin//	j = iMiddle////	for k := iBegin to iEnd inclusive do://		if i < iMiddle && (j >= iEnd || A[i] <= A[j])://			B[k] = A[i]//			i = i + 1//		else //			B[k] = A[j]//			j = j + 1//		end if//	end for////CopyArray(A[], iBegin, iEnd, B[])//	for k := iBegin to iEnd inclusive do://		B[k] = A[k]//	end for